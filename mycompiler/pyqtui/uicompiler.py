__author__ = 'Nathan Starkweather'
'''

Created by: Nathan Starkweather
Created on: 01/19/2014
Created in: PyCharm Community Edition


'''
from mycompiler.pyqtui.base import MyUiBase
from mycompiler.pyqtui.uicontroller import UiController

from PyQt5.uic.Compiler.indenter import getIndenter, write_code as write_view_code
from classwriter import *
from datetime import datetime
from os import makedirs


uifile = 'C:\\Python33\\Lib\\site-packages\\PyQt5\\myprojects\\ui\\MyIDE.ui'
view_file = 'C:\\Users\\Administrator\\Documents\\Programming\\PythonSource\\source\\mycompiler\\pyqtui\\ideui.py'
controller_file = 'C:\\Users\\Administrator\\Documents\\Programming\\PythonSource\\source\\mycompiler\\pyqtui\\uicontroller_auto.py'

backup_folder = 'C:\\Users\\Administrator\\Documents\\Programming\\PythonSource\\source\\mycompiler\\pyqtui\\uiarchive\\%m%d%Y'
controller_bkup_name = "uicontroller%m%d%Y%H%M.py"
view_bkup_name = 'ideui%m%d%Y%H%M.py'

controller_imports = """
from mycompiler.pyqtui.base import UiControllerBase
from PyQt5.QtWidgets import QMainWindow"""

controller_cls_def = "class UiController(UiControllerBase):"

controller_doc = '''
    \'\'\' Controller for a PyQt5 uic-created ui, autogenerated
    from script %s.

    Class body is generated from the list of connections
    found in the .ui file generated by QtDesigner, and should
    in all cases always have a list of every connection made
    with appropriate arguments, a simple docstring, and
    simple annotation.

    This class, located at:

    %s

    should therefore only be used with its co-generated class at:

    %s

    Failure to do so may result in mismatched signal/slot
    definitions in the view setupUi() protocol.

    \'\'\'''' % (__file__, '%s', '%s')

controller_init = '''def __init__(self):
        \'\'\' Placeholder \'\'\'
        pass
        '''

controller_connect_def = '''def connectView(self, View: object):'''

controller_connect_doc = '''\'\'\'Connect the controller to an instance of a class
corresponding to a PyQt5 uic-created UI.\'\'\''''

controller_connect_body = '''
mainWindow = QMainWindow()
View.setupUi(mainWindow, self)

self.View = View
self.mainWindow = mainWindow'''

controller_slot_body = 'pass'

controller_slot_def = "def %s(self%s):"

controller_slot_doc = '''\'\'\'Signal handler from widget \'%s\' connecting
signal\'%s\'.
\'\'\''''


class DerpError(Exception):
    pass


class PyQtUiCompiler(MyUiBase):
    ''' Re-separating the implementation of the
    hook into PyQt5 UIC with the writing of the
    controller class that the UI should correspond
    to. This should make the ClassWriter more
    extensible and useful for other things besides
    just this project.

    This class, on the other hand, should be designed
    for the specific purpose of hooking the class UI
    creation process that PyQt's UIC uses, by subclassing
    UiCompiler and re-implementing our own copies of
    functions to control aspects of the creation
    process that we want.

    '''

    # Stuff for the module to import

    view_import_def = "from PyQt5 import QtWidgets, QtCore"

    # Class and UI setup definition

    ui_cls_name = "%sView"
    ui_cls_name_def = "class %s():" % ui_cls_name
    setup_ui_def = "def setupUi(self, %s, controller):"

    def __init__(self, uifile: str=uifile, viewfile: str=view_file):

        self.uifile = uifile
        self.viewfile = viewfile
        self.connections_list = None
        super().__init__()

    def _createConnections(self, elem):
        '''This is the big important function. This can
        be used with the hookConnections() (or just removing the '_')
        to hook into the signal/slot creation logic from UICompiler.

        This lets us redirect and customize how we want to do the creation.

        1/18/2014- Currently function is a bit of a mess since it is all
         in debug mode.
        '''

        connections_list = []

        for conn in elem:
            sender = conn.findtext('sender')
            signal = conn.findtext('signal')
            slot = conn.findtext('slot')

            slot_name, _slot_args = slot.split('(')
            sig, sig_args = signal.split('(')
            sig_args = sig_args[:-1].replace(' ', '')

            if sig_args:
                conn_type = "%s['%s']" % (sig, sig_args)
            else:
                conn_type = sig

            connect_code = ("self.%s.%s.connect(controller.%s)" % (sender,
                                                                   conn_type,
                                                                   slot_name))

            write_view_code(connect_code)

            connections_list.append((slot_name, sig_args, sender))

        self.connections_list = connections_list

    # hook/unhook UICompiler's createConnections
    # first sets class variable to default
    # second saves a hard reference to swap at will
    createConnections = MyUiBase.createConnections
    super_createConnections = createConnections

    def hookConnections(self):
        self.createConnections = self._createConnections

    def unhookConnections(self):
        self.createConnections = self.super_createConnections

    def createToplevelWidget(self, classname, widgetname):
        '''This is mostly copy/pasted from the UIC code,
        but with some small changes that allow some
        custom creation of the class name and setupUi
        code.
        '''

        indenter = getIndenter()
        indenter.level = 0

        indenter.write(self.view_import_def)
        indenter.write("")

        indenter.write(self.ui_cls_name_def % "IDE")
        indenter.indent()
        indenter.write(self.setup_ui_def % widgetname)
        indenter.indent()
        w = self.factory.createQObject(classname, widgetname, (),
                                       is_attribute=False,
                                       no_instantiation=True)
        w.baseclass = classname
        w.uiclass = self.ui_cls_name % self.uiname
        return w

    def createModule(self, uifile: str, view_file: str):

        with open(uifile, 'r') as ui:
            with open(view_file, 'w') as pyfile:
                self.compileUi(input_stream=ui,
                               output_stream=pyfile,
                               from_imports=False,
                               resource_suffix='_rc')

    def buildControllerProxy(self) -> ClassProxy:

        connections = self.connections_list

        if not connections:
            # Eventually, just read the XML directly
            raise DerpError("Forgot to build connections list, dummy")

        klass = ClassProxy(name='UiController',
                           bases=('UiControllerBase',),
                           doc=controller_doc % (controller_file.replace('\\', '/'), view_file.replace('\\','/')),
                            ide_comments=["noinspection PyMethodMayBeStatic"])

        setup = MethodProxy(name="connectView",
                            doc=controller_connect_doc,
                            body=controller_connect_body)
        setup.addArg("View")

        klass.addMethod(setup)

        for slot_name, sig_args, sender in connections:

            if sig_args == 'bool':
                sig_args = 'QBool'

            method = MethodProxy(name=slot_name,
                                   args=ArgsProxy([sig_args]),
                                   # doc=controller_slot_doc % (sender, sig_args),
                                   body=['print("%s called", %s)' % (slot_name, sig_args)])

            klass.addMethod(method)

        return klass


def backup_pyfile(from_file, to_file):

    with open(from_file, 'r') as f:
        contents = f.read()

    with open(to_file, 'w') as f:
        f.write(contents)


def parse_timestamp(name: str) -> str:

    now = datetime.now()
    out = now.strftime(name)
    if out == name:
        out += "%m%d%Y%H%M"
        out = now.strftime(out)
    return out



def make_backup_folder(backup_folder: str=backup_folder) -> str:

    folder = parse_timestamp(backup_folder)
    try:
        makedirs(folder)
    except OSError:
        pass
    return folder


def make_backup_file(file: str, folder: str=None) -> str:

    if folder is None:
        folder = backup_folder
    folder = make_backup_folder(folder)
    file = parse_timestamp(file)

    return '\\'.join((folder, file))


def compileUI():
    '''
    @return: None
    @rtype: None

    Compile the IDE.ui file, build a controller class for the signals/
    slots defined by the .ui file, cross reference with those functions
    already defined by the active in-progress uicontroller.py file,
    and auto-generate any undefined methods.
    '''
    c = PyQtUiCompiler()
    c.hookConnections()
    c.createModule(uifile, view_file)
    klass = c.buildControllerProxy()

    klass.methods = {k: v for k, v in klass.methods.items() if k not in UiController.__dict__}

    w = ClassWriter()
    w.write_buffer.append('from mycompiler.pyqtui.base import UiControllerBase\n')
    w.write_buffer.append('from PyQt5.QtWidgets import QMainWindow\n')

    with open(controller_file, 'w') as f:
        w.compileClass(klass, f)

    view_bkup = make_backup_file(view_bkup_name)
    controller_bkup = make_backup_file(controller_bkup_name)

    backup_pyfile(view_file, view_bkup)
    backup_pyfile(controller_file, controller_bkup)


if __name__ == '__main__':

    compileUI()



